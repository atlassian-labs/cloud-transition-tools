package com.atlassian.ctt.data.loader.jcma

import com.atlassian.ctt.data.loader.LoaderStatus
import com.atlassian.ctt.data.loader.LoaderStatusCode
import com.atlassian.ctt.data.loader.MigrationMappingLoader
import com.atlassian.ctt.data.loader.MigrationScope
import com.atlassian.ctt.data.store.MigrationMapping
import com.atlassian.ctt.data.store.MigrationStore
import com.atlassian.ctt.service.HTTPRequestService
import com.atlassian.ctt.service.HTTPResponse
import kotlinx.coroutines.delay
import mu.KotlinLogging

const val JCMA_ID_MAPPING_URL = "/rest/migration/latest/report/id-mappings"
const val JCMA_RELOAD_PARAM = "invalidateCache"
const val JCMA_RETRY_INTERVAL = 5000L // 5 seconds

/*
 * JCMAMigrationMappingLoader loads ID mappings from Jira Cloud Migration Assistant (JCMA).
 * This loads the mapping information from JCMA_ID_MAPPING_URL and stores it in the data store.
 * https://confluence.atlassian.com/migrationkb/api-to-fetch-id-mappings-from-jira-cloud-migration-assistant-1388159626.html
 */
class JCMAMigrationMappingLoader(
    scope: MigrationScope,
    private val authHeader: String,
) : MigrationMappingLoader(scope) {
    private val logger = KotlinLogging.logger(this::class.java.name)

    override suspend fun load(
        dataStore: MigrationStore,
        reload: Boolean,
    ): LoaderStatus {
        if (!reload) {
            logger.info { "Skipping ID mapping as reload is not requested" }
            return LoaderStatus(LoaderStatusCode.LOADED, "Skipping ID mappings load").also {
                setLoaderStatus(it)
            }
        }
        // Download the id mapping data asynchronously
        // This will keep calling the downloadIDMappings function until the data is loaded
        downloadIdMappingsSuspend(authHeader, dataStore)
        return getLoaderStatus()
    }

    private suspend fun downloadIdMappingsSuspend(
        authHeader: String,
        dataStore: MigrationStore,
    ) {
        setLoaderStatus(LoaderStatus(LoaderStatusCode.LOADING, "ID mappings are being loaded"))
        var reload = true
        do {
            val status =
                downloadIDMappings(scope.serverBaseURL, scope.cloudSiteURL, authHeader, dataStore, reload).also {
                    setLoaderStatus(it)
                }
            if (status.code == LoaderStatusCode.FAILED) {
                break
            }

            delay(JCMA_RETRY_INTERVAL)
            reload = false
        } while (status.code == LoaderStatusCode.LOADING)

        setLoaderStatus(getLoaderStatus())
    }

    private fun downloadIDMappings(
        serverBaseURL: String,
        cloudSiteUrl: String,
        authHeader: String,
        dataStore: MigrationStore,
        reload: Boolean = false,
    ): LoaderStatus {
        val url = "$serverBaseURL$JCMA_ID_MAPPING_URL?cloudSiteUrl=$cloudSiteUrl&$JCMA_RELOAD_PARAM=$reload"
        logger.info { "Downloading ID mappings from $url" }
        val headers = mapOf("Authorization" to authHeader)

        try {
            val response: HTTPResponse = HTTPRequestService().get(url, headers)
            if (response.isError()) {
                logger.error(response.text()) { "Failed to download ID mappings" }
                return LoaderStatus(
                    LoaderStatusCode.FAILED,
                    "Failed to download ID mappings Status Code: ${response.status()} Error: ${response.text()}",
                )
            } else if (response.isAccepted()) {
                logger.info { "ID mappings are being generated" }
                return LoaderStatus(LoaderStatusCode.LOADING, "ID mappings are being generated by the server")
            }

            if (!response.isOk() || response.contentType()?.startsWith("text/csv") != true) {
                logger.error { "Invalid response from server. Expected CSV. Obtained ${response.contentType()}" }
                return LoaderStatus(LoaderStatusCode.FAILED, "Invalid response from server. Expected CSV")
            }
            val csvStream: java.io.InputStream =
                response.byteStream() ?: return LoaderStatus(LoaderStatusCode.FAILED, "Failed to get CSV stream")
            parseCSVStreamToDataStore(csvStream, dataStore)
        } catch (e: Exception) {
            logger.error(e) { "Failed to download ID mappings" }
            return LoaderStatus(LoaderStatusCode.FAILED, e.toString())
        }

        return getLoaderStatus()
    }

    private fun parseCSVStreamToDataStore(
        stream: java.io.InputStream,
        dataStore: MigrationStore,
    ) {
        logger.info { "Parsing ID mappings from CSV stream" }

        stream.bufferedReader().use {
            // Validate header
            val header = it.readLine().split(",")
            if (header != listOf("entityType", "serverId", "cloudId")) {
                logger.error { "Invalid CSV header" }
                setLoaderStatus(LoaderStatus(LoaderStatusCode.FAILED, "Invalid CSV header"))
                return
            }

            // Parse mapping content
            it.forEachLine { line ->
                try {
                    val values = line.split(",")
                    val (entityType, serverId, cloudId) = values
                    val idMapping =
                        MigrationMapping(scope.serverBaseURL, entityType, serverId.toLong(), cloudId.toLong())
                    dataStore.store(idMapping)
                } catch (e: Exception) {
                    logger.error(e) { "Failed to parse ID mapping entry: $line" }
                }
            }
        }
        logger.info { "ID mappings stored in data store" }
        setLoaderStatus(LoaderStatus(LoaderStatusCode.LOADED, "ID mappings downloaded"))
    }
}
