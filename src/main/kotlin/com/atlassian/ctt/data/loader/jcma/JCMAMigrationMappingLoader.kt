package com.atlassian.ctt.data.loader.jcma

import com.atlassian.ctt.data.MigrationMapping
import com.atlassian.ctt.data.loader.LoaderStatus
import com.atlassian.ctt.data.loader.LoaderStatusCode
import com.atlassian.ctt.data.loader.MigrationMappingLoader
import com.atlassian.ctt.data.loader.MigrationScope
import com.atlassian.ctt.data.store.MigrationStore
import com.atlassian.ctt.service.HTTPCredentials
import com.atlassian.ctt.service.HTTPRequestService
import com.atlassian.ctt.service.HTTPResponse
import kotlinx.coroutines.delay
import mu.KotlinLogging

const val JCMA_ID_MAPPING_URL = "/rest/migration/latest/report/id-mappings"

/*
 * JCMAMigrationMappingLoader is a MigrationMappingLoader implementation that loads ID mappings from Jira Cloud Migration Assistant (JCMA).
 * This loads the mapping information from JCMA_ID_MAPPING_URL and stores it in the data store.
 * Refer https://confluence.atlassian.com/migrationkb/api-to-fetch-id-mappings-from-jira-cloud-migration-assistant-1388159626.html for more details.
 *
 */
class JCMAMigrationMappingLoader(
    scope: MigrationScope,
    dataStore: MigrationStore,
    private val params: JCMALoaderParams,
) : MigrationMappingLoader(scope, dataStore) {
    private val logger = KotlinLogging.logger(this::class.java.name)

    override suspend fun load(): LoaderStatus {
        if (!params.reload) {
            logger.info { "Skipping ID mapping as reload is not requested" }
            return LoaderStatus(LoaderStatusCode.LOADED, "Skipping ID mappings load").also {
                setLoaderStatus(it)
            }
        }

        logger.info { "Loading ID mappings MigrationScope: $scope" }
        val userName = params.username
        val password = params.password
        val pat = params.pat

        var authorization = "basic"
        if (userName == null || password == null) {
            if (pat == null) {
                return LoaderStatus(LoaderStatusCode.FAILED, "No authentication provided").also {
                    setLoaderStatus(it)
                }
            }
            authorization = "pat"
        }

        val credentials =
            when (authorization) {
                "basic" -> HTTPCredentials.basic(userName!!, password!!)
                "pat" -> "Bearer $pat"
                else -> throw IllegalArgumentException("Invalid authorization type: $authorization").also {
                    setLoaderStatus(LoaderStatus(LoaderStatusCode.FAILED, "Invalid authorization type"))
                }
            }

        downloadIdMappingsSuspend(credentials, params.reload)
        return getLoaderStatus()
    }

    private suspend fun downloadIdMappingsSuspend(
        authorization: String,
        reload: Boolean = false,
    ) {
        var invalidateCache = reload
        setLoaderStatus(LoaderStatus(LoaderStatusCode.LOADING, "ID mappings are being loaded"))
        do {
            val status =
                downloadIDMappings(scope.serverBaseURL, scope.cloudSiteURL, authorization, invalidateCache).also {
                    invalidateCache = false
                    setLoaderStatus(it)
                }
            if (status.code == LoaderStatusCode.FAILED) {
                break
            }
            // Can make this configurable if required
            delay(5000)
        } while (status.code == LoaderStatusCode.LOADING)

        setLoaderStatus(getLoaderStatus())
    }

    private fun downloadIDMappings(
        serverBaseURL: String,
        cloudSiteUrl: String,
        authorization: String,
        invalidateCache: Boolean,
    ): LoaderStatus {
        val url = "$serverBaseURL$JCMA_ID_MAPPING_URL?cloudSiteUrl=$cloudSiteUrl&invalidateCache=$invalidateCache"
        logger.info { "Downloading ID mappings from $url" }
        val headers = mapOf("Authorization" to authorization)

        try {
            val response: HTTPResponse = HTTPRequestService().get(url, headers)
            if (response.isError()) {
                logger.error(response.text()) { "Failed to download ID mappings" }
                return LoaderStatus(
                    LoaderStatusCode.FAILED,
                    "Failed to download ID mappings Status Code: ${response.status()} Error: ${response.text()}",
                )
            } else if (response.isAccepted()) {
                logger.info { "ID mappings are being generated" }
                return LoaderStatus(LoaderStatusCode.LOADING, "ID mappings are being generated by the server")
            }

            logger.info { "ID mappings downloaded from server" }
            assert(response.isOk())
            assert(response.contentType() == "text/csv")
            val csvStream: java.io.InputStream =
                response.byteStream() ?: return LoaderStatus(LoaderStatusCode.FAILED, "Failed to download ID mappings")
            parseCSVStreamToDataStore(csvStream)
        } catch (e: Exception) {
            logger.error(e) { "Failed to download ID mappings" }
            return LoaderStatus(LoaderStatusCode.FAILED, "Failed to download ID mappings")
        }

        return LoaderStatus(LoaderStatusCode.LOADED, "ID mappings downloaded")
    }

    private fun parseCSVStreamToDataStore(stream: java.io.InputStream) {
        logger.info { "Parsing ID mappings from CSV stream" }

        stream.bufferedReader().use {
            // Validate header
            val header = it.readLine().split(",")
            if (header != listOf("entityType", "serverId", "cloudId")) {
                setLoaderStatus(LoaderStatus(LoaderStatusCode.FAILED, "Invalid CSV header"))
                return
            }

            // Parse mapping content
            it.forEachLine { line ->
                try {
                    val values = line.split(",")
                    val (entityType, serverId, cloudId) = values
                    val idMapping = MigrationMapping(entityType, serverId.toLong(), cloudId.toLong())
                    dataStore.store(idMapping)
                } catch (e: Exception) {
                    logger.error(e) { "Failed to parse ID mapping entry: $line" }
                }
            }
        }
        logger.info { "ID mappings stored in data store" }
    }
}
